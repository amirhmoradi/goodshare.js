'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = require('fs');
var googleClosureCompiler = require('google-closure-compiler');
var MagicString = _interopDefault(require('magic-string'));
var tempWrite = require('temp-write');
var path = require('path');

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dynamicImport = require('acorn-dynamic-import');
const DYNAMIC_IMPORT_DECLARATION = dynamicImport.DynamicImportKey;
const IMPORT_SPECIFIER = 'ImportSpecifier';
const IMPORT_DEFAULT_SPECIFIER = 'ImportDefaultSpecifier';
const IMPORT_NAMESPACE_SPECIFIER = 'ImportNamespaceSpecifier';
var ExportClosureMapping;
(function (ExportClosureMapping) {
    ExportClosureMapping[ExportClosureMapping["NAMED_FUNCTION"] = 0] = "NAMED_FUNCTION";
    ExportClosureMapping[ExportClosureMapping["NAMED_CLASS"] = 1] = "NAMED_CLASS";
    ExportClosureMapping[ExportClosureMapping["NAMED_DEFAULT_FUNCTION"] = 2] = "NAMED_DEFAULT_FUNCTION";
    ExportClosureMapping[ExportClosureMapping["DEFAULT_FUNCTION"] = 3] = "DEFAULT_FUNCTION";
    ExportClosureMapping[ExportClosureMapping["NAMED_DEFAULT_CLASS"] = 4] = "NAMED_DEFAULT_CLASS";
    ExportClosureMapping[ExportClosureMapping["DEFAULT_CLASS"] = 5] = "DEFAULT_CLASS";
    ExportClosureMapping[ExportClosureMapping["NAMED_CONSTANT"] = 6] = "NAMED_CONSTANT";
    ExportClosureMapping[ExportClosureMapping["DEFAULT"] = 7] = "DEFAULT";
    ExportClosureMapping[ExportClosureMapping["DEFAULT_VALUE"] = 8] = "DEFAULT_VALUE";
    ExportClosureMapping[ExportClosureMapping["DEFAULT_OBJECT"] = 9] = "DEFAULT_OBJECT";
})(ExportClosureMapping || (ExportClosureMapping = {}));
class Transform {
    constructor(context, inputOptions) {
        this.name = 'Transform';
        this.context = context;
        this.inputOptions = inputOptions;
    }
    extern(options) {
        return '';
    }
    async preCompilation(code) {
        return {
            code,
        };
    }
    async postCompilation(code) {
        return {
            code,
        };
    }
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const HEADER = `/**
 * @fileoverview Externs built via derived configuration from Rollup or input code.
 * This extern contains the iife name so it does not get mangled at the top level.
 * @externs
 */
`;
/**
 * This Transform will apply only if the Rollup configuration is for a iife output with a defined name.
 *
 * In order to preserve the name of the iife output, derive an extern definition for Closure Compiler.
 * This preserves the name after compilation since Closure now believes it to be a well known global.
 */
class IifeTransform extends Transform {
    constructor() {
        super(...arguments);
        this.name = 'IifeTransform';
    }
    extern(options) {
        if (options.format === 'iife' && options.name) {
            return HEADER + `window['${options.name}'] = ${options.name};\n`;
        }
        return '';
    }
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const acorn = require('acorn');
const acornWalk = require('acorn-walk');
const dynamicImport$1 = require('acorn-dynamic-import');
const DYNAMIC_IMPORT_BASEVISITOR = Object.assign({}, acornWalk.base, {
    [DYNAMIC_IMPORT_DECLARATION]: () => { },
});
const walk = {
    simple(node, visitors) {
        acornWalk.simple(node, visitors, DYNAMIC_IMPORT_BASEVISITOR);
    },
    ancestor(node, visitors) {
        acornWalk.ancestor(node, visitors, DYNAMIC_IMPORT_BASEVISITOR);
    },
};
const DEFAULT_ACORN_OPTIONS = {
    ecmaVersion: 2019,
    sourceType: 'module',
    preserveParens: false,
    ranges: true,
};
function parse(source) {
    return acorn.Parser.extend(dynamicImport$1.default).parse(source, DEFAULT_ACORN_OPTIONS);
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Closure Compiler will not transform computed keys with literal values back to the literal value.
 * e.g {[0]: 'value'} => {0: 'value'}
 *
 * This transform does so only if a computed key is a Literal, and thus easily known to be static.
 * @see https://astexplorer.net/#/gist/d2414b45a81db3a41ee6902bfd09947a/d7176ac33a2733e1a4b1f65ec3ac626e24f7b60d
 */
class LiteralComputedKeys extends Transform {
    constructor() {
        super(...arguments);
        this.name = 'LiteralComputedKeysTransform';
    }
    /**
     * @param code source to parse, and modify
     * @return modified input source with computed literal keys
     */
    async postCompilation(code) {
        const source = new MagicString(code);
        const program = parse(code);
        walk.simple(program, {
            ObjectExpression(node) {
                const properties = node.properties;
                properties.forEach(property => {
                    if (property.computed &&
                        property.key.type === 'Literal' &&
                        property.range &&
                        property.value.range) {
                        source.overwrite(property.range[0], property.value.range[0], `${property.key.value}${property.value.type !== 'FunctionExpression' ? ':' : ''}`);
                    }
                });
            },
        });
        return {
            code: source.toString(),
            map: source.generateMap().mappings,
        };
    }
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function NamedDeclaration(context, declaration) {
    const range = declaration.range;
    const source = declaration.source && declaration.source.value && typeof declaration.source.value === 'string'
        ? declaration.source.value
        : null;
    if (declaration.specifiers) {
        const exportDetails = [];
        for (const specifier of declaration.specifiers) {
            exportDetails.push({
                local: specifier.local.name,
                exported: specifier.exported.name,
                closureName: specifier.exported.name,
                type: ExportClosureMapping.NAMED_CONSTANT,
                range,
                source,
            });
        }
        return exportDetails;
    }
    return [];
}
function DefaultDeclaration(context, declaration) {
    if (declaration.declaration) {
        const range = declaration.range;
        const source = null;
        if (declaration.declaration.type === 'Identifier' && declaration.declaration.name) {
            return [
                {
                    local: declaration.declaration.name,
                    exported: declaration.declaration.name,
                    closureName: declaration.declaration.name,
                    type: ExportClosureMapping.NAMED_DEFAULT_FUNCTION,
                    range,
                    source,
                },
            ];
        }
    }
    return [];
}
function literalName(context, literal) {
    // Literal can either be a SimpleLiteral, or RegExpLiteral
    if ('regex' in literal) {
        // This is a RegExpLiteral
        context.warn('Rollup Plugin Closure Compiler found a Regex Literal Named Import. `import foo from "*/.hbs"`');
        return '';
    }
    const literalValue = literal.value;
    return typeof literalValue === 'string' ? literalValue : '';
}
function importLocalNames(context, declaration) {
    const VALID_SPECIFIERS = [IMPORT_SPECIFIER, IMPORT_NAMESPACE_SPECIFIER, IMPORT_DEFAULT_SPECIFIER];
    const returnableSpecifiers = [];
    (declaration.specifiers || []).forEach(specifier => {
        if (VALID_SPECIFIERS.includes(specifier.type)) {
            returnableSpecifiers.push(specifier.local.name);
        }
    });
    return returnableSpecifiers;
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* c8 ignore next 9 */
const logSource = (preamble, source, code) => {
};

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_WARNINGS_ENABLED_LANGUAGE_OUT_UNSPECIFIED = 'Providing the warning_level=VERBOSE compile option also requires a valid language_out compile option.';
const ERROR_WARNINGS_ENABLED_LANGUAGE_OUT_INVALID = 'Providing the warning_level=VERBOSE and language_out=NO_TRANSPILE compile options will remove warnings.';
/**
 * Checks if output format is ESM
 * @param format
 * @return boolean
 */
const isESMFormat = (format) => {
    // TODO: remove `| 'esm'` when rollup upgrades its typings
    return format === 'esm' || format === 'es';
};
/**
 * Throw Errors if compile options will result in unexpected behaviour.
 * @param compileOptions
 */
const validateCompileOptions = (compileOptions) => {
    if ('warning_level' in compileOptions && compileOptions.warning_level === 'VERBOSE') {
        if (!('language_out' in compileOptions)) {
            throw new Error(ERROR_WARNINGS_ENABLED_LANGUAGE_OUT_UNSPECIFIED);
        }
        else if ('language_out' in compileOptions && compileOptions.language_out === 'NO_TRANSPILE') {
            throw new Error(ERROR_WARNINGS_ENABLED_LANGUAGE_OUT_INVALID);
        }
    }
};
/**
 * Generate default Closure Compiler CompileOptions an author can override if they wish.
 * These must be derived from configuration or input sources.
 * @param transformers
 * @param options
 * @return derived CompileOptions for Closure Compiler
 */
const defaults = (options, providedExterns, transformers) => {
    // Defaults for Rollup Projects are slightly different than Closure Compiler defaults.
    // - Users of Rollup tend to transpile their code before handing it to a minifier,
    // so no transpile is default.
    // - When Rollup output is set to "es|esm" it is expected the code will live in a ES Module,
    // so safely be more aggressive in minification.
    const externs = transformers
        ? transformers
            .map(transform => {
            const extern = transform.extern(options);
            return extern !== '' ? tempWrite.sync(extern) : false;
        })
            .filter(Boolean)
            .concat(providedExterns)
        : providedExterns.length > 0
            ? providedExterns
            : '';
    return {
        language_out: 'NO_TRANSPILE',
        assume_function_wrapper: isESMFormat(options.format),
        warning_level: 'QUIET',
        module_resolution: 'NODE',
        externs,
    };
};
/**
 * Compile Options is the final configuration to pass into Closure Compiler.
 * defaultCompileOptions are overrideable by ones passed in directly to the plugin
 * but the js source and sourcemap are not overrideable, since this would break the output if passed.
 * @param compileOptions
 * @param outputOptions
 * @param code
 * @param transforms
 */
function options (incomingCompileOptions, outputOptions, code, transforms) {
    const mapFile = tempWrite.sync('');
    const compileOptions = { ...incomingCompileOptions };
    let externs = [];
    validateCompileOptions(compileOptions);
    if ('externs' in compileOptions) {
        switch (typeof compileOptions.externs) {
            case 'boolean':
                externs = [];
                break;
            case 'string':
                externs = [compileOptions.externs];
                break;
            default:
                externs = compileOptions.externs;
                break;
        }
        delete compileOptions.externs;
    }
    const options = {
        ...defaults(outputOptions, externs, transforms),
        ...compileOptions,
        js: tempWrite.sync(code),
        create_source_map: mapFile,
    };
    return [options, mapFile];
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EXTERN_OVERVIEW = `/**
* @fileoverview Externs built via derived configuration from Rollup or input code.
* @externs
*/`;
const CJS_EXTERN = `/**
 * @typedef {{
 *   __esModule: boolean,
 * }}
 */
var exports;`;
/**
 * This Transform will apply only if the Rollup configuration is for 'esm' output.
 *
 * In order to preserve the export statements:
 * 1. Create extern definitions for them (to keep them their names from being mangled).
 * 2. Insert additional JS referencing the exported names on the window scope
 * 3. After Closure Compilation is complete, replace the window scope references with the original export statements.
 */
class ExportTransform extends Transform {
    constructor() {
        super(...arguments);
        this.name = 'ExportTransform';
        this.originalExports = new Map();
        this.currentSourceExportCount = 0;
        /**
         * Store an export from a source into the originalExports Map.
         * @param mapping mapping of details from this declaration.
         */
        this.storeExport = (mapping) => mapping.forEach(map => {
            if (map.source === null) {
                this.currentSourceExportCount++;
            }
            this.originalExports.set(map.closureName, map);
        });
    }
    static storeExportToAppend(collected, exportDetails) {
        const update = collected.get(exportDetails.source) || [];
        if (exportDetails.exported === exportDetails.local) {
            update.push(exportDetails.exported);
        }
        else {
            update.push(`${exportDetails.local} as ${exportDetails.exported}`);
        }
        collected.set(exportDetails.source, update);
        return collected;
    }
    async deriveExports(code) {
        const { context, storeExport } = this;
        const program = parse(code);
        walk.simple(program, {
            ExportNamedDeclaration(node) {
                storeExport(NamedDeclaration(context, node));
            },
            ExportDefaultDeclaration(node) {
                storeExport(DefaultDeclaration(context, node));
            },
            ExportAllDeclaration(node) {
                // TODO(KB): This case `export * from "./import"` is not currently supported.
                context.error(new Error(`Rollup Plugin Closure Compiler does not support export all syntax for externals.`));
            },
        });
    }
    extern(options) {
        let output = EXTERN_OVERVIEW;
        if (options.format === 'cjs') {
            output += CJS_EXTERN;
        }
        for (const key of this.originalExports.keys()) {
            const value = this.originalExports.get(key);
            if (value.source !== null) {
                output += `function ${value.closureName}(){};\n`;
            }
        }
        return output;
    }
    /**
     * Before Closure Compiler modifies the source, we need to ensure it has window scoped
     * references to the named exports. This prevents Closure from mangling their names.
     * @param code source to parse, and modify
     * @param chunk OutputChunk from Rollup for this code.
     * @param id Rollup id reference to the source
     * @return modified input source with window scoped references.
     */
    async preCompilation(code) {
        if (this.outputOptions === null) {
            this.context.warn('Rollup Plugin Closure Compiler, OutputOptions not known before Closure Compiler invocation.');
        }
        else if (isESMFormat(this.outputOptions.format)) {
            await this.deriveExports(code);
            const source = new MagicString(code);
            for (const key of this.originalExports.keys()) {
                const value = this.originalExports.get(key);
                // Remove export statements before Closure Compiler sees the code
                // This prevents CC from transpiling `export` statements when the language_out is set to a value
                // where exports were not part of the language.
                source.remove(...value.range);
                // Window scoped references for each key are required to ensure Closure Compilre retains the code.
                if (value.source === null) {
                    source.append(`\nwindow['${value.closureName}'] = ${value.local};`);
                }
                else {
                    source.append(`\nwindow['${value.closureName}'] = ${value.exported};`);
                }
            }
            return {
                code: source.toString(),
                map: source.generateMap().mappings,
            };
        }
        return {
            code,
        };
    }
    /**
     * After Closure Compiler has modified the source, we need to replace the window scoped
     * references we added with the intended export statements
     * @param code source post Closure Compiler Compilation
     * @param chunk OutputChunk from Rollup for this code.
     * @param id Rollup identifier for the source
     * @return Promise containing the repaired source
     */
    async postCompilation(code) {
        if (this.outputOptions === null) {
            this.context.warn('Rollup Plugin Closure Compiler, OutputOptions not known before Closure Compiler invocation.');
        }
        else if (isESMFormat(this.outputOptions.format)) {
            const source = new MagicString(code);
            const program = parse(code);
            let collectedExportsToAppend = new Map();
            const { originalExports, currentSourceExportCount } = this;
            source.trimEnd();
            walk.ancestor(program, {
                // We inserted window scoped assignments for all the export statements during `preCompilation`
                // Now we need to find where Closure Compiler moved them, and restore the exports of their name.
                // ASTExporer Link: https://astexplorer.net/#/gist/94f185d06a4105d64828f1b8480bddc8/0fc5885ae5343f964d0cdd33c7d392a70cf5fcaf
                Identifier(node, ancestors) {
                    if (node.name === 'window') {
                        ancestors.forEach((ancestor) => {
                            if (ancestor.type === 'ExpressionStatement' &&
                                ancestor.expression.type === 'AssignmentExpression' &&
                                ancestor.expression.left.type === 'MemberExpression' &&
                                ancestor.expression.left.object.type === 'Identifier' &&
                                ancestor.expression.left.object.name === 'window') {
                                const { property: leftProperty } = ancestor.expression.left;
                                let exportName = null;
                                if (leftProperty.type === 'Identifier') {
                                    exportName = leftProperty.name;
                                }
                                else if (leftProperty.type === 'Literal' &&
                                    typeof leftProperty.value === 'string') {
                                    exportName = leftProperty.value;
                                }
                                if (exportName !== null && originalExports.get(exportName)) {
                                    const exportDetails = originalExports.get(exportName);
                                    switch (exportDetails.type) {
                                        case ExportClosureMapping.NAMED_DEFAULT_FUNCTION:
                                        case ExportClosureMapping.DEFAULT:
                                            if (ancestor.expression.left.range) {
                                                source.overwrite(ancestor.expression.left.range[0], ancestor.expression.left.range[1] + ancestor.expression.operator.length, 'export default ');
                                            }
                                            break;
                                        case ExportClosureMapping.NAMED_CONSTANT:
                                            const exportFromCurrentSource = exportDetails.source === null;
                                            const inlineExport = exportFromCurrentSource && currentSourceExportCount === 1;
                                            let exportCollected = false;
                                            if (exportFromCurrentSource) {
                                                const { object: leftObject } = ancestor.expression.left;
                                                if (leftObject.range) {
                                                    const { left, right } = ancestor.expression;
                                                    switch (right.type) {
                                                        case 'FunctionExpression':
                                                            // Function Expressions can be inlined instead of preserved as variable references.
                                                            // window['foo'] = function(){}; => export function foo(){} / function foo(){}
                                                            if (right.params.length > 0) {
                                                                // FunctionExpression has parameters.
                                                                source.overwrite(leftObject.range[0], right.params[0].range[0], `${inlineExport ? 'export ' : ''}function ${exportDetails.exported}(`);
                                                            }
                                                            else {
                                                                source.overwrite(leftObject.range[0], right.body.range[0], `${inlineExport ? 'export ' : ''}function ${exportDetails.exported}()`);
                                                            }
                                                            break;
                                                        case 'Identifier':
                                                            if (left.property.type === 'Identifier') {
                                                                // Identifiers are present when a complex object (class) has been saved as an export.
                                                                // In this case we currently opt out of inline exporting, since the identifier
                                                                // is a mangled name for the export.
                                                                exportDetails.local = right.name;
                                                                exportDetails.closureName = left.property.name;
                                                                source.remove(ancestor.expression.left.range[0], ancestor.expression.right.range[1] + 1);
                                                                // Since we're manually mapping the name back from the changes done by Closure
                                                                // Ensure the export isn't stored for insertion here and later on.
                                                                collectedExportsToAppend = ExportTransform.storeExportToAppend(collectedExportsToAppend, exportDetails);
                                                                exportCollected = true;
                                                            }
                                                            break;
                                                        default:
                                                            const statement = inlineExport ? 'export var ' : 'var ';
                                                            source.overwrite(leftObject.range[0], leftObject.range[1] + 1, statement);
                                                            break;
                                                    }
                                                }
                                                if (exportDetails.local !== exportDetails.exported) {
                                                    exportDetails.local = exportDetails.exported;
                                                    exportDetails.closureName = exportDetails.local;
                                                }
                                            }
                                            else if (ancestor.expression.left.range &&
                                                ancestor.expression.right.range) {
                                                source.remove(ancestor.expression.left.range[0], ancestor.expression.right.range[1] + 1);
                                            }
                                            if (!inlineExport && !exportCollected) {
                                                collectedExportsToAppend = ExportTransform.storeExportToAppend(collectedExportsToAppend, exportDetails);
                                            }
                                            break;
                                    }
                                }
                            }
                        });
                    }
                },
            });
            for (const exportSource of collectedExportsToAppend.keys()) {
                const toAppend = collectedExportsToAppend.get(exportSource);
                if (toAppend && toAppend.length > 0) {
                    if (exportSource === null) {
                        source.append(`export{${toAppend.join(',')}}`);
                    }
                    else {
                        source.prepend(`export{${toAppend.join(',')}}from'${exportSource}';`);
                    }
                }
            }
            return {
                code: source.toString(),
                map: source.generateMap().mappings,
            };
        }
        return {
            code,
        };
    }
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DYNAMIC_IMPORT_KEYWORD = 'import';
const DYNAMIC_IMPORT_REPLACEMENT = `import_${new Date().getMilliseconds()}`;
const HEADER$1 = `/**
* @fileoverview Externs built via derived configuration from Rollup or input code.
* This extern contains the external import names, to prevent compilation failures.
* @externs
*/
`;
class ImportTransform extends Transform {
    constructor() {
        super(...arguments);
        this.importedExternalsSyntax = {};
        this.importedExternalsLocalNames = [];
        this.dynamicImportPresent = false;
        this.name = 'ImportTransform';
    }
    /**
     * Generate externs for local names of external imports.
     * Otherwise, advanced mode compilation will fail since the reference is unknown.
     * @return string representing content of generated extern.
     */
    extern() {
        let extern = HEADER$1;
        if (this.importedExternalsLocalNames.length > 0) {
            this.importedExternalsLocalNames.forEach(name => {
                extern += `function ${name}(){};\n`;
            });
        }
        if (this.dynamicImportPresent) {
            extern += `
/**
 * @param {string} path
 * @return {!Promise<?>}
 */
function ${DYNAMIC_IMPORT_REPLACEMENT}(path) { return Promise.resolve(path) };
window['${DYNAMIC_IMPORT_REPLACEMENT}'] = ${DYNAMIC_IMPORT_REPLACEMENT};`;
        }
        return extern;
    }
    /**
     * Before Closure Compiler modifies the source, we need to ensure external imports have been removed
     * since Closure will error out when it encounters them.
     * @param code source to parse, and modify
     * @param chunk OutputChunk from Rollup for this code.
     * @param id Rollup id reference to the source
     * @return modified input source with external imports removed.
     */
    async preCompilation(code) {
        const self = this;
        const source = new MagicString(code);
        const program = parse(code);
        walk.simple(program, {
            async ImportDeclaration(node) {
                const name = literalName(self.context, node.source);
                const range = node.range;
                let defaultSpecifier = null;
                const specificSpecifiers = [];
                for (const specifier of node.specifiers) {
                    switch (specifier.type) {
                        case IMPORT_SPECIFIER:
                        case IMPORT_NAMESPACE_SPECIFIER:
                            const { name: local } = specifier.local;
                            const { name: imported } = specifier.imported;
                            specificSpecifiers.push(local === imported ? local : `${imported} as ${local}`);
                            break;
                        case IMPORT_DEFAULT_SPECIFIER:
                            defaultSpecifier = specifier.local.name;
                            break;
                    }
                }
                self.importedExternalsSyntax[name] = `import ${defaultSpecifier !== null
                    ? `${defaultSpecifier}${specificSpecifiers.length > 0 ? ',' : ''}`
                    : ''}${specificSpecifiers.length > 0 ? `{${specificSpecifiers.join(',')}}` : ''} from '${name}';`;
                source.remove(...range);
                self.importedExternalsLocalNames = self.importedExternalsLocalNames.concat(importLocalNames(self.context, node));
            },
            Import(node) {
                const [start, end] = node.range;
                self.dynamicImportPresent = true;
                // Rename the `import` method to something we can put in externs.
                // CC doesn't understand dynamic import yet.
                source.overwrite(start, end, code.substring(start, end).replace(DYNAMIC_IMPORT_KEYWORD, DYNAMIC_IMPORT_REPLACEMENT));
            },
        });
        return {
            code: source.toString(),
            map: source.generateMap().mappings,
        };
    }
    /**
     * After Closure Compiler has modified the source, we need to re-add the external imports
     * @param code source post Closure Compiler Compilation
     * @return Promise containing the repaired source
     */
    async postCompilation(code) {
        const source = new MagicString(code);
        const program = parse(code);
        Object.values(this.importedExternalsSyntax).forEach(importedExternalSyntax => source.prepend(importedExternalSyntax));
        walk.simple(program, {
            Identifier(node) {
                if (node.name === DYNAMIC_IMPORT_REPLACEMENT) {
                    const [start, end] = node.range;
                    source.overwrite(start, end, DYNAMIC_IMPORT_KEYWORD);
                }
            },
        });
        return {
            code: source.toString(),
            map: source.generateMap().mappings,
        };
    }
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StrictTransform extends Transform {
    constructor() {
        super(...arguments);
        this.name = 'StrictTransform';
    }
    /**
     * When outputting an es module, runtimes automatically apply strict mode conventions.
     * This means we can safely strip the 'use strict'; declaration from the top of the file.
     * @param code source following closure compiler minification
     * @return code after removing the strict mode declaration (when safe to do so)
     */
    async postCompilation(code) {
        if (this.outputOptions === null) {
            this.context.warn('Rollup Plugin Closure Compiler, OutputOptions not known before Closure Compiler invocation.');
        }
        else if (isESMFormat(this.outputOptions.format) ||
            (this.outputOptions.file && path.extname(this.outputOptions.file) === '.mjs')) {
            const source = new MagicString(code);
            const program = parse(code);
            walk.simple(program, {
                ExpressionStatement(node) {
                    if (node.expression.type === 'Literal' &&
                        node.expression.value === 'use strict' &&
                        node.range) {
                        source.remove(node.range[0], node.range[1]);
                    }
                },
            });
            return {
                code: source.toString(),
                map: source.generateMap().mappings,
            };
        }
        return {
            code,
        };
    }
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ConstTransform extends Transform {
    constructor() {
        super(...arguments);
        this.name = 'ConstTransform';
    }
    /**
     * When outputting ES2017+ code there is neglagible differences between `const` and `let` for runtime performance.
     * So, we replace all usages of `const` with `let` to enable more variable folding.
     * @param code source following closure compiler minification
     * @return code after removing the strict mode declaration (when safe to do so)
     */
    async preCompilation(code) {
        const source = new MagicString(code);
        const program = parse(code);
        walk.simple(program, {
            VariableDeclaration(node) {
                if (node.kind === 'const' && node.range) {
                    source.overwrite(node.range[0], node.range[1], code.substring(node.range[0], node.range[1]).replace('const ', 'let '));
                }
            },
        });
        return {
            code: source.toString(),
            map: source.generateMap().mappings,
        };
    }
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Instantiate transform class instances for the plugin invocation.
 * @param context Plugin context to bind for each transform instance.
 * @param options Rollup input options
 * @return Instantiated transform class instances for the given entry point.
 */
const createTransforms = (context, options) => {
    return [
        new ConstTransform(context, options),
        new IifeTransform(context, options),
        new LiteralComputedKeys(context, options),
        new StrictTransform(context, options),
        new ExportTransform(context, options),
        new ImportTransform(context, options),
    ];
};
/**
 * Run each transform's `preCompilation` phase.
 * @param code source code to modify with `preCompilation` before Closure Compiler is given it.
 * @param outputOptions Rollup's configured output options
 * @param transforms Transforms to execute.
 * @return source code following `preCompilation`
 */
async function preCompilation(code, outputOptions, transforms) {
    for (const transform of transforms) {
        transform.outputOptions = outputOptions;
        const result = await transform.preCompilation(code);
        if (result && result.code) {
            logSource(`after ${transform.name} preCompilation`, result && result.code);
            code = result.code;
        }
    }
    return code;
}
/**
 * Run each transform's `postCompilation` phase.
 * @param code source code to modify with `postCompilation` after Closure Compiler has finished.
 * @param transforms Transforms to execute.
 * @return source code following `postCompilation`
 */
async function postCompilation(code, transforms) {
    for (const transform of transforms) {
        const result = await transform.postCompilation(code);
        if (result && result.code) {
            logSource(`after ${transform.name} postCompilation`, result && result.code);
            code = result.code;
        }
    }
    return code;
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const { getNativeImagePath, getFirstSupportedPlatform, } = require('google-closure-compiler/lib/utils.js');
var Platform;
(function (Platform) {
    Platform["NATIVE"] = "native";
    Platform["JAVA"] = "java";
    Platform["JAVASCRIPT"] = "javascript";
})(Platform || (Platform = {}));
const DEFAULT_PLATFORM_PRECEDENCE = [Platform.NATIVE, Platform.JAVA, Platform.JAVASCRIPT];
/**
 * Splits user `platform` option from compiler options object
 * returns new object containing options and preferred platform.
 * @param {CompileOptions} content - compiler options object
 * @return {Object}
 * @example in rollup.config.js
 *  compiler({
 *    platform: 'javascript',
 *  }),
 */
function filterContent(content) {
    let platform = '';
    if ('platform' in content && typeof content.platform === 'string') {
        platform = content.platform;
        delete content.platform;
    }
    return [content, platform];
}
/**
 * Reorders platform preferences based on configuration.
 * @param {String} platformPreference - preferred platform string
 * @return {Array}
 */
function orderPlatforms(platformPreference) {
    if (platformPreference === '') {
        return DEFAULT_PLATFORM_PRECEDENCE;
    }
    const index = DEFAULT_PLATFORM_PRECEDENCE.indexOf(platformPreference);
    const newPlatformPreferences = DEFAULT_PLATFORM_PRECEDENCE.splice(index, 1);
    return newPlatformPreferences.concat(DEFAULT_PLATFORM_PRECEDENCE);
}
/**
 * Run Closure Compiler and `postCompilation` Transforms on input source.
 * @param compileOptions Closure Compiler CompileOptions, normally derived from Rollup configuration
 * @param transforms Transforms to run rollowing compilation
 * @return Promise<string> source following compilation and Transforms.
 */
function compiler (compileOptions, transforms) {
    return new Promise((resolve, reject) => {
        const [config, platform] = filterContent(compileOptions);
        const instance = new googleClosureCompiler.compiler(config);
        const firstSupportedPlatform = getFirstSupportedPlatform(orderPlatforms(platform));
        if (firstSupportedPlatform !== Platform.JAVA) {
            // TODO(KB): Provide feedback on this API. It's a little strange to nullify the JAR_PATH
            // and provide a fake java path.
            instance.JAR_PATH = null;
            instance.javaPath = getNativeImagePath();
        }
        instance.run(async (exitCode, code, stdErr) => {
            if ('warning_level' in compileOptions &&
                compileOptions.warning_level === 'VERBOSE' &&
                stdErr !== '') {
                reject(new Error(`Google Closure Compiler ${stdErr}`));
            }
            else if (exitCode !== 0) {
                reject(new Error(`Google Closure Compiler exit ${exitCode}: ${stdErr}`));
            }
            else {
                resolve(await postCompilation(code, transforms));
            }
        });
    });
}

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Transform the tree-shaken code from Rollup with Closure Compiler (with derived configuration and transforms)
 * @param compileOptions Closure Compiler compilation options from Rollup configuration.
 * @param transforms Transforms to apply to source followin Closure Compiler completion.
 * @param code Source to compile.
 * @param outputOptions Rollup Output Options.
 * @return Closure Compiled form of the Rollup Chunk
 */
const renderChunk = async (transforms, requestedCompileOptions = {}, sourceCode, outputOptions) => {
    const code = await preCompilation(sourceCode, outputOptions, transforms);
    const [compileOptions, mapFile] = options(requestedCompileOptions, outputOptions, code, transforms);
    try {
        return {
            code: await compiler(compileOptions, transforms),
            map: JSON.parse(await fs.promises.readFile(mapFile, 'utf8')),
        };
    }
    catch (error) {
        throw error;
    }
};
function closureCompiler(requestedCompileOptions = {}) {
    let inputOptions;
    let context;
    return {
        name: 'closure-compiler',
        options: options => (inputOptions = options),
        buildStart() {
            context = this;
            if ('compilation_level' in requestedCompileOptions &&
                requestedCompileOptions.compilation_level === 'ADVANCED_OPTIMIZATIONS' &&
                Array.isArray(inputOptions.input)) {
                context.warn('Code Splitting with Closure Compiler ADVANCED_OPTIMIZATIONS is not currently supported.');
            }
        },
        renderChunk: async (code, chunk, outputOptions) => {
            const transforms = createTransforms(context, inputOptions);
            const output = await renderChunk(transforms, requestedCompileOptions, code, outputOptions);
            return output || null;
        },
    };
}

module.exports = closureCompiler;
